generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String            @id @default(cuid())
  email                   String            @unique
  password                String
  name                    String
  phone                   String?
  userType                UserType
  emailVerified           DateTime?
  verificationToken       String?           @unique
  verificationTokenExpires DateTime?
  resetToken              String?           @unique
  resetTokenExpires       DateTime?
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  bookings                Booking[]
  receivedMessages        Message[]         @relation("MessageReceiver")
  sentMessages            Message[]         @relation("MessageSender")
  parkingSpots            ParkingSpot[]
  termsAcceptances        TermsAcceptance[]
  vehicles                Vehicle[]

  @@map("users")
}

model ParkingSpot {
  id                      String      @id @default(cuid())
  userId                  String
  type                    ParkingType
  address                 String
  latitude                Float?
  longitude               Float?
  imageUrl                String?
  qrCode                  String?     @unique
  pricePerHour            Float
  pricePerMinute          Float?
  description             String?
  isActive                Boolean     @default(true)
  supportsAdvanceBooking  Boolean     @default(true)
  supportsOnDemandBooking Boolean     @default(false)
  gpsToleranceMeters      Float?      @default(50)
  zoneNumber              String?
  zoneName                String?
  operator                String?
  createdAt               DateTime    @default(now())
  updatedAt               DateTime    @updatedAt
  bookings                Booking[]
  user                    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([latitude, longitude])
  @@map("parking_spots")
}

model Booking {
  id              String           @id @default(cuid())
  parkingSpotId   String
  userId          String
  bookingType     BookingType     @default(ADVANCE)
  startTime       DateTime
  endTime         DateTime?       // Nullable for ON_DEMAND, but REQUIRED for ADVANCE (validated in app)
  actualStartTime DateTime?
  actualEndTime   DateTime?
  totalPrice      Float?          // Nullable for ON_DEMAND, but REQUIRED for ADVANCE (validated in app)
  estimatedPrice  Float?
  durationMinutes Int?
  status          BookingStatus   @default(PENDING)
  qrCode          String?         @unique
  gpsStartLat     Float?
  gpsStartLng     Float?
  gpsEndLat       Float?
  gpsEndLng       Float?
  vehiclePlate    String?
  vehicleId       String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  cancelledAt     DateTime?
  parkingSpot     ParkingSpot     @relation(fields: [parkingSpotId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  vehicle         Vehicle?        @relation(fields: [vehicleId], references: [id], onDelete: SetNull)
  messages        Message[]
  termsAcceptance TermsAcceptance?

  @@index([parkingSpotId])
  @@index([userId])
  @@index([startTime, endTime])
  @@index([status, bookingType])
  @@index([userId, status])
  @@map("bookings")
}

model Message {
  id         String   @id @default(cuid())
  bookingId  String
  senderId   String
  receiverId String
  content    String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  receiver   User     @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([senderId, receiverId])
  @@map("messages")
}

model TermsAcceptance {
  id         String   @id @default(cuid())
  bookingId  String   @unique
  userId     String
  accepted   Boolean  @default(true)
  acceptedAt DateTime @default(now())
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("terms_acceptances")
}

model Payment {
  id              String      @id @default(cuid())
  bookingId       String      @unique
  amount          Float
  currency        String      @default("NOK")
  stripePaymentId String?     @unique
  status          String
  paymentType     PaymentType  @default(ADVANCE)
  refundedAt      DateTime?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([bookingId])
  @@map("payments")
}

model Vehicle {
  id          String   @id @default(cuid())
  userId      String
  plateNumber String
  make        String?
  model       String?
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings    Booking[]

  @@index([userId])
  @@map("vehicles")
}

enum UserType {
  UTLEIER
  LEIETAKER
}

enum ParkingType {
  UTENDORS
  INNENDORS
}

enum BookingType {
  ADVANCE
  ON_DEMAND
}

enum BookingStatus {
  PENDING
  CONFIRMED
  ACTIVE
  COMPLETED
  CANCELLED
  STARTED
}

enum PaymentType {
  ADVANCE
  ON_DEMAND
}
